import { _ } from "svelte-i18n";
import {
  get,
  writable,
  type Readable,
  type Writable,
  derived,
} from "svelte/store";
import { writableDerived } from "svelte-writable-derived";

import type {
  IGroupModel,
  IItemModel,
  IRelationsModel,
  IStorageModel,
} from "$type/storage";
import { Group, Item } from "$type/data";

import { firebaseStorageAPI } from "$api/firebase";

let _loadedStorageAPI = firebaseStorageAPI;

let _defaultGroup = new Group(
  "default_group",
  get(_)("nav.all_items"),
  undefined,
  undefined,
  {
    isEditable: false,
    isRemovable: false,
    isHidden: false,
    isAutoGenerated: true,
  }
);
let _searchGroup = new Group(
  "search_group",
  get(_)("nav.search_results"),
  undefined,
  undefined,
  {
    isEditable: false,
    isRemovable: false,
    isHidden: true,
    isAutoGenerated: true,
    isReadOnly: true,
  }
);

const _findItemIndexById = (id: string, group = _defaultGroup): number =>
  group.items.findIndex((groupItem) => groupItem.id === id);
const _findGroupIndexById = (id: string): number =>
  get(storage).findIndex((storageGroup) => storageGroup.id === id);

const _findItemById = (id: string, group = _defaultGroup): Item =>
  group.items[_findItemIndexById(id, group)] as Item;
const _findGroupById = (id: string): Group =>
  get(storage)[_findGroupIndexById(id)] as Group;

const storage: Writable<Group[]> = writable([_defaultGroup, _searchGroup]);

const groups: Readable<Group[]> = derived(storage, ($storage) =>
  $storage.filter((group) => !group.flags.isAutoGenerated)
);

const groupsLoaded: Writable<boolean> = writable(false);
const itemsLoaded: Writable<boolean> = writable(false);

const selectedGroupIndex: Writable<number> = writable(-1);
const selectedGroup: Writable<Group> = writableDerived(
  selectedGroupIndex,
  (s) => {
    const group = get(storage)[s];
    return group;
  },
  (value: Group) => {
    let index: any = get(selectedGroupIndex);
    let _old: Group = get(selectedGroup);

    if (index === -1) return;

    if (_old?.id != value.id) index = _findGroupIndexById(value.id);
    else {
      if (value.flags.isEditable) group.update(value);
    }
    return index;
  }
);

const loadItemsForGroup = async (group: Group) => {
  const sort = (items) =>
    items.sort(group.sortFunction).map((item: Item, index: number) => {
      item.groupIndex = index;
      return item;
    });
  if (!group.id) return [];

  if (get(itemsLoaded) || group.flags.itemsLoaded) {
    group.flags.itemsLoaded = true;
    return sort(group.items);
  }

  const itemsAsync =
    group.id === _defaultGroup.id
      ? await _loadedStorageAPI.item.loadAll()
      : await _loadedStorageAPI.item.loadForGroup(group.id);

  itemsAsync.forEach((item: Item) => {
    if (!_findItemById(item.id)) Storage.item.load(item);
  });

  group.items = itemsAsync;
  group.flags.itemsLoaded = true;

  storage.update((groups) => {
    groups[_findGroupIndexById(group.id)] = group;
    return groups;
  });

  if (group.id === get(selectedGroup).id)
    selectedGroup.update((group) => group);

  if (group.id === _defaultGroup.id) itemsLoaded.set(true);
};

const selectedIndex: Writable<number> = writable(-1);

const timeForSave = 1000;
let saveTimeout = null;

const setupUpdate = function (_item) {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(() => {
    _item.flags.needSave = false;
    item.update(_item);
    _item.flags.justUpdated = true;
    if (_item.id === get(selectedItem).id) selectedItem.update((item) => item);
  }, timeForSave);
};
const forceUpdate = function (_item) {
  if (_item?.flags?.needSave) {
    clearTimeout(saveTimeout);
    _item.flags.needSave = false;
    _item.flags.justUpdated = true;
    item.update(_item);
  }
};

const selectedItem: Writable<Item> = writableDerived(
  selectedIndex,
  ($s) => _defaultGroup.items[$s] || ({} as Item),
  (value: Item) => {
    const prevItem = _defaultGroup.items[get(selectedIndex)];
    if (!value.id) return -1;
    if (value.id === prevItem?.id) {
      value.flags.needSave = true;
      if (!value.flags.justUpdated) setupUpdate(value);
      value.flags.justUpdated = false;
      return get(selectedIndex);
    } else {
      if (prevItem) forceUpdate(prevItem);
      return _findItemIndexById(value.id);
    }
  }
);

//persevering selected item beetween groups
selectedGroup.subscribe((group: Group) => {
  if (!group?.items || !group.id || !get(groupsLoaded)) return;
  if (group.items.length > 0) {
    const _selectedItem: Item = get(selectedItem);
    const index: number = _selectedItem.id
      ? _findItemIndexById(_selectedItem.id, group)
      : 0;

    selectedItem.set(group.items[index !== -1 ? index : 0]);
  } else selectedItem.set({} as Item);
});

const _removeItemFromGroupOnly = (
  group: Group,
  id: string,
  dontUpdateStores = false
) => {
  group.items.splice(
    group.items.findIndex((it) => it.id === id),
    1
  );
  if (!dontUpdateStores) Storage.group.update(group);
};
const _removeGroupFromItemOnly = (
  item: Item,
  groupId: string,

) => {
  const _index: number = item.groups.findIndex((_g) => _g === groupId);
  if (_index != -1) item.groups.splice(_index, 1);
};

const _removeItemFromGroup = (
  group: Group,
  item: Item,
  dontUpdateStores = false
) => {
  _removeGroupFromItemOnly(item, group.id);
  _removeItemFromGroupOnly(group, item.id, dontUpdateStores);
};
const _addItemToGroup = (
  group: Group,
  item: Item,
  dontUpdateStores = false
) => {
  group.items.push(item);
  item.groups.push(group.id);

  if (!dontUpdateStores) Storage.group.update(group);
};

const _updateItem = function (item: Item) {
  item.modifyDate = new Date();
  _loadedStorageAPI.item.update(item);
};

export const group: IGroupModel = {
  load: async function (group: Group) {
    storage.update((_storage) => {
      _storage.push(group);
      return _storage;
    });
    return group;
  },
  loadAll: async () => {
    await _loadedStorageAPI.group
      .loadAll()
      .then((groups) =>
        groups
          .sort((a: Group, b: Group) => (a.createDate > b.createDate ? 1 : -1))
          .forEach((_item) => group.load(_item))
      );
    groupsLoaded.set(true);
  },
  add: async function (_group: Group) {
    _group.id = _loadedStorageAPI.generateGroupId();

    group.load(_group);
    group.select(_group);

    _loadedStorageAPI.group.add(_group);
  },
  update: async function (group: Group) {
    if (!group.flags.isEditable) return;

    group.modifyDate = new Date();
    group.itemsCount = group.items.length;

    const _index = _findGroupIndexById(group.id);
    storage.update((__storage) => {
      __storage[_index] = group;
      return __storage;
    });

    _loadedStorageAPI.group.update(group);
  },
  remove: async function (groupId: string) {
    const _groupIndex: number = _findGroupIndexById(groupId);

    if (_groupIndex === 0) return;

    const _storage: Group[] = get(storage);
    const _group: Group = _storage[_groupIndex];

    _group.items.forEach((_item) => {
      _removeGroupFromItemOnly(_item, _group.id);
      _loadedStorageAPI.item.update(_item);
    });

    storage.update((_storage) => {
      _storage.splice(_groupIndex, 1);
      return _storage;
    });

    if (get(selectedGroupIndex) === _groupIndex) group.selectDefault();

    return await _loadedStorageAPI.group.remove(_group.id);
  },
  select: function (group: Group) {
    const groupIndex: number = _findGroupIndexById(group.id);
    selectedGroupIndex.set(groupIndex);
    loadItemsForGroup(group);
    //event
  },
  selectDefault: function () {
    group.select(_defaultGroup);
  },
  getAll: () =>
    get(storage).filter((group: Group) => !group.flags.isAutoGenerated),
  getDefault: () => _defaultGroup,
  get: (groupId: string) => _findGroupById(groupId),
  sort: function (group: Group, method = () => 0) {
    group.sortFunction = method;

    if (group.id === get(selectedGroup).id)
      selectedGroup.update((group) => group);

    return group;
  },
  selectedGroup: selectedGroup,
  selectedGroupIndex: selectedGroupIndex,
  groupsLoaded: groupsLoaded,
  groups,
};
export const item: IItemModel = {
  load: async function (item: Item) {
    _defaultGroup.items.push(item);
    item.groups.forEach((groupId) => {
      storage.update((_storage) => {
        const _group = _findGroupById(groupId);
        if (!_group) throw new Error(`Group with id ${groupId} not found`);
        _group.items.push(item);
        return _storage;
      });
    });

    return item;
  },
  loadAll: async () =>
    await (
      await _loadedStorageAPI.item.loadAll()
    ).forEach((_item: Item) => item.load(_item)),
  add: async function (newItem: Item) {
    newItem.id = _loadedStorageAPI.generateItemId();
    _defaultGroup.items.push(newItem);

    selectedItem.set(newItem);

    if (get(selectedGroup).id !== _defaultGroup.id) {
      newItem.groups.push(get(selectedGroup).id);
      selectedGroup.update((group) => {
        group.items.push(newItem);
        return group;
      });
    } else selectedGroup.update((group) => group);

    await _loadedStorageAPI.item.add(newItem);
  },
  update: async function (item: Item) {
    item.modifyDate = new Date();
    let _item: Item = _findItemById(item.id) || ({} as Item);
    await _loadedStorageAPI.item.update(item);
  },
  remove: async function (itemId: any) {
    const _index: number = _findItemIndexById(itemId);
    const _item: Item = _defaultGroup.items[_index];

    _item.groups.forEach((groupId: string) =>
      _removeItemFromGroupOnly(_findGroupById(groupId), _item.id)
    );

    _removeItemFromGroupOnly(_defaultGroup, _item.id);

    if (get(selectedGroup).items.length > 0) {
      if (get(selectedIndex) === _index) item.selectIndex(0);
    } else item.unSelect();

    selectedGroup.update((group) => group);

    //event
    return await _loadedStorageAPI.item.remove(_item.id);
  },
  select: function (item: Item) {
    selectedItem.set(item);
  },
  selectIndex: function (index: number) {
    selectedItem.set(get(selectedGroup).items[index]);
  },
  unSelect: function () {
    selectedIndex.set(-1);
  },
  get: (itemId: string, group: Group) => _findItemById(itemId, group),
  getAll: () => _defaultGroup.items,

  selectedItem: selectedItem,
  selectedIndex: selectedIndex,
  itemsLoaded: itemsLoaded,
};
export const relations: IRelationsModel = {
  addTo: function (group: Group, item: Item) {
    if (relations.isItemInGroup(item, group)) return;

    _addItemToGroup(group, item);
    Storage.group.update(group);
    _updateItem(item);
    selectedItem.update((_item) => _item);
  },
  removeFrom: function (group: Group, item: Item) {
    if (!relations.isItemInGroup(item, group)) return;

    _removeItemFromGroup(group, item);
    Storage.group.update(group);
    _updateItem(item);
    selectedItem.update((_item) => _item);
  },
  setFor: function (item: Item, groupsId: string[]) {
    const _storage = get(storage);

    _storage.forEach((_group) => {
      if (_group.id === _defaultGroup.id) return;

      const setListHaveGroupId =
        groupsId.findIndex((_id) => _id === _group.id) !== -1;
      const isItemInGroup = relations.isItemInGroup(item, _group);

      if (setListHaveGroupId) {
        if (!isItemInGroup) {
          _addItemToGroup(_group, item, true);
          Storage.group.update(_group);
        }
      } else {
        if (isItemInGroup) {
          _removeItemFromGroup(_group, item, true);
          Storage.group.update(_group);
        }
      }
    });
    storage.update((_storage) => _storage);
    if (get(selectedItem).id === item.id) selectedItem.set(item);
    _updateItem(item);
  },
  isItemInGroup: function (item: Item, group: Group) {
    return item.groups.findIndex((_groupId) => _groupId === group.id) !== -1;
  },
};

export const clearStorage = async () => {
  storage.set([_defaultGroup, _searchGroup]);
  _defaultGroup.items = [];
  _defaultGroup.flags.itemsLoaded = false;
  _searchGroup.items = [];
  itemsLoaded.set(false);
  groupsLoaded.set(false);
  selectedGroupIndex.set(0);
  selectedIndex.set(-1);
};

export let Storage: IStorageModel = {
  group: group,
  item: item,
  relations: relations,

  storage: storage,
};
